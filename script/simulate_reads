#!/usr/bin/env perl 
#===============================================================================
#
#         FILE: simulate_reads
#
#        USAGE: ./simulate-reads [OPTIONS] <FASTA>
#
#  DESCRIPTION:
#
#      OPTIONS: 
# REQUIREMENTS:
#         BUGS: ---
#        NOTES: ---
#       AUTHOR: Thiago Miller
# ORGANIZATION: IEP - Hospital Sírio-Libanês
#      VERSION: 1.0
#      CREATED: 24-02-2017 18:26:51
#     REVISION: ---
#===============================================================================

use My::Base;
use Getopt::Long;
use Pod::Usage;
use File::Basename 'basename';
use Fastq::SingleEnd;
use Fastq::PairedEnd;
use SimulateRead;

#-------------------------------------------------------------------------------
#  Default values, constants and definitions
#-------------------------------------------------------------------------------
use constant {
	PROGNAME              => basename($0),
	VERBOSE               => 0,
	PREFIX                => 'out',
	JOBS                  => 1,
	OUTPUT_GZIP           => 1,
	COUNT_LOOPS_BY        => 'coverage',
	COVERAGE              => 1,
	STRAND_BIAS           => 'random',
	SEQID_WEIGHT          => 'length',
	SEQUENCING_TYPE       => 'paired-end',
	FRAGMENT_MEAN         => 300,
	FRAGMENT_STDD         => 50,
	SEQUENCING_ERROR      => 0.005,
	READ_SIZE             => 101,
	SEQUENCING_SYSTEM     => 'hiseq',
	COUNT_LOOPS_BY_OPT    => ['coverage', 'number-of-reads'],
	STRAND_BIAS_OPT       => ['random', 'plus', 'minus'],
	SEQID_WEIGHT_OPT      => ['length', 'same', 'file'],
	SEQUENCING_TYPE_OPT   => ['single-end', 'paired-end'],
	SEQUENCING_SYSTEM_OPT => ['hiseq']
};

# Decisions
my $count_loops_by    = COUNT_LOOPS_BY;

# Default values
my $prefix            = PREFIX;
my $jobs              = JOBS;
my $output_gzip       = OUTPUT_GZIP;
my $coverage          = COVERAGE;
my $read_size         = READ_SIZE;
my $fragment_mean     = FRAGMENT_MEAN;
my $fragment_stdd     = FRAGMENT_STDD;
my $sequencing_error  = SEQUENCING_ERROR;
my $sequencing_type   = SEQUENCING_TYPE;
my $sequencing_system = SEQUENCING_SYSTEM;
my $strand_bias       = STRAND_BIAS;
my $seqid_weight      = SEQID_WEIGHT;

# Optional values
my $number_of_reads;
my $weight_file;

# Help messages
my $man = 0;
my $help = 0;

# Possible alternatives
my %STRAND_BIAS       = map { $_ => 1 } @{ &STRAND_BIAS_OPT       };
my %SEQID_WEIGHT      = map { $_ => 1 } @{ &SEQID_WEIGHT_OPT      };
my %SEQUENCING_TYPE   = map { $_ => 1 } @{ &SEQUENCING_TYPE_OPT   }; 
my %SEQUENCING_SYSTEM = map { $_ => 1 } @{ &SEQUENCING_SYSTEM_OPT };

# Mandatory arguments
my $fasta_file;

# Print error message to STDERR and die
sub error($) {
	my $progname = PROGNAME;
	my $err = "$progname: ";
	$err .= shift;
	chomp $err;
	$err .= "\nTry '$progname --help' for more information";
	die "$err\n";
}

sub log_msg_opt(%) {
	my %opt = @_;
	while (my ($key, $value) = each %opt) {
		next if ref($value) =~ /Fastq/;
		$value = "not defined" if not defined $value;
		$key =~ s/_/ /g;
		log_msg "  => $key $value";
	}
}

#-------------------------------------------------------------------------------
#  Parsing command-line arguments
#-------------------------------------------------------------------------------
my @ARGV_STORED = @ARGV;

GetOptions(
	'man'                 => \$man,
	'help|?'              => \$help,
	'verbose|s'           => \$LOG_VERBOSE,
	'prefix=s'            => \$prefix,
	'jobs=i'              => \$jobs,
	'output-gzip!'        => \$output_gzip,
	'coverage=f'          => \$coverage,
	'read-size=i'         => \$read_size,
	'fragment-mean=i'     => \$fragment_mean,
	'fragment-stdd=i'     => \$fragment_stdd,
	'sequencing-error=f'  => \$sequencing_error,
	'sequencing-type=s'   => \$sequencing_type,
	'sequencing-system=s' => \$sequencing_system,
	'strand-bias=s'       => \$strand_bias,
	'seqid-weight=s'      => \$seqid_weight,
	'number-of-reads=i'   => \$number_of_reads,
	'weight-file=s'       => \$weight_file
) or error "Error in command line arguments";

pod2usage(1) if $help;
pod2usage(-verbose => 2) if $man;

$fasta_file = shift;

#-------------------------------------------------------------------------------
#  Validating arguments
#-------------------------------------------------------------------------------

## Independently validated arguments

# Mandatory fasta file
if (not defined $fasta_file) {
	error "Missing fasta file";
}

# Ut is really a file?
if (not -f $fasta_file) {
	error "<$fasta_file> is not a file. Please, give me a valid fasta file";
}

# Check the file extension: fasta, fa, fna, ffn followed, or not, by .gz 
if ($fasta_file !~ /.+\.(fasta|fa|fna|ffn)(\.gz)*$/) {
	error "<$fasta_file> does not seem to be a fasta file. Please check the file extension";
}

# jobs > 0
if ($jobs <= 0) {
	error "Option 'jobs' requires an integer greater than zero, not $jobs";
}

# 0 <= sequencing_error <= 1
if (0 > $sequencing_error || $sequencing_error > 1)  {
	error "Option 'sequencing-error' requires a value between zero and one, not $sequencing_error";
}

# sequencing_system eq hiseq for now
if (lc $sequencing_system ne SEQUENCING_SYSTEM) {
	error "Option 'sequencing-system' has only one valid option for now: 'hiseq', not $sequencing_system";
}

# strand_bias (STRAND_BIAS_OPT)
if (not exists $STRAND_BIAS{$strand_bias}) {
	my $opt = join ', ' => keys %STRAND_BIAS;
	error "Option 'strand-bias' requires one of these arguments: $opt not $strand_bias";
}

# sequencing_type (SEQUENCING_TYPE_OPT)
if (not exists $SEQUENCING_TYPE{$sequencing_type}) {
	my $opt = join ', ' => keys %SEQUENCING_TYPE;
	error "Option 'sequencing-type' requires one of these arguments: $opt not $sequencing_type";
}

# 0 < read_size <= 101. It will become more complex when sequencing_system increase
if (0 > $read_size || $read_size > READ_SIZE) {
	error "Option 'read-size' requires an integer greater than zero and lesser than " . READ_SIZE . ", not $read_size";
}

## Dependently validated arguments

# fragment_mean and fragment_stdd
if ($sequencing_type eq 'paired-end') {
	# fragment_mean > 0
	if ($fragment_mean <= 0) {
		error "Option 'fragment-mean' requires a value greater than zero, not $fragment_mean";
	}

	# fragment_stdd > 0
	if ($fragment_stdd <= 0) {
		error "Option 'fragment-stdd' requires a value greater than zero, not $fragment_stdd";
	}

	# (fragment_mean - fragment_stdd) >= read_size
	if (($fragment_mean - $fragment_stdd) < $read_size) {
		error "Option 'fragment-mean' minus 'fragment-stdd' requires a value greater or equal read-size, not " .
			($fragment_mean - $fragment_stdd);
	}
}

# count_loops_by (COUNT_LOOPS_BY_OPT). The default value is counting by coverage
# Or calculate number of reads by coverage, or the user pass the number_of_reads.
# number-of-reads option overrides coverage
if (defined $number_of_reads) {
	# number_of_reads > 0
	if ($number_of_reads <= 0) {
		error "Option 'number-of-reads' requires a value greater than zero, not $number_of_reads";
	}

	# sequencing_type eq paired-end requires at least 2 reads
	if ($number_of_reads < 2 && $sequencing_type eq 'paired-end') {
		error "Option 'number-of-reads' requires a value greater or equal to 2 for paired-end reads, not $number_of_reads";
	}
	$count_loops_by = 'number_of_reads';
} else {
	# coverage > 0
	if ($coverage <= 0) {
		error "Option 'coverage' requires a value greater than zero, not $coverage";
	}
}

# seqid_weight (SEQID_WEIGHT_OPT)
if (not exists $SEQID_WEIGHT{$seqid_weight}) {
	my $opt = join ', ' => keys %SEQID_WEIGHT;
	error "Option 'seqid-weight' requires one of these arguments: $opt not $seqid_weight";
}

# seqid_weight eq 'file' requires a weight_file
if ($seqid_weight eq 'file') {
	if (not defined $weight_file) {
		error "Option 'seqid-weight=file' requires the argument 'weight-file' with a tab-separated values file";
	}

	# It is defined, but the file exists?
	if (not -f $weight_file) {
		error "Option 'weight-file' requires a valid file, not $weight_file";
	}
}

#-------------------------------------------------------------------------------
#  Log presentation header
#-------------------------------------------------------------------------------
my $time_stamp = localtime;
my $progname = PROGNAME;
log_msg <<"HEADER";
-------------------------------------------------------
   $progname -- IEP Hsopital Sírio-Libanês
   Date $time_stamp
-------------------------------------------------------
:: Parameters passed by the user: '@ARGV_STORED'
HEADER

#-------------------------------------------------------------------------------
#  Construct the Fastq and SimulateRead classes
#-------------------------------------------------------------------------------
my %paired_end_param = (
	sequencing_system => $sequencing_system,
	sequencing_error  => $sequencing_error,
	read_size         => $read_size,
	fragment_mean     => $fragment_mean,
	fragment_stdd     => $fragment_stdd
);

my %single_end_param = (
	sequencing_system => $sequencing_system,
	sequencing_error  => $sequencing_error,
	read_size         => $read_size,
);

my $fastq;
if ($sequencing_type eq 'paired-end') {
	log_msg ":: Creating paired-end fastq generator ...";
	log_msg_opt %paired_end_param;
	try {
		$fastq = Fastq::PairedEnd->new(%paired_end_param);
	} catch {
		error "$_";
	};
} else {
	log_msg ":: Creating single-end fastq generator ...";
	log_msg_opt %single_end_param;
	try {
		$fastq = Fastq::SingleEnd->new(%single_end_param);
	} catch {
		error "$_";
	};
}

my %simulator_param = (
	fastq             => $fastq,
	prefix            => $prefix,
	output_gzip       => $output_gzip,
	fasta_file        => $fasta_file,
	count_loops_by    => $count_loops_by,
	number_of_reads   => $number_of_reads,
	coverage          => $coverage,
	jobs              => $jobs,
	strand_bias       => $strand_bias,
	seqid_weight      => $seqid_weight,
	weight_file       => $weight_file
);

my $simulator;
log_msg ":: Creating simulator ...";
log_msg_opt %simulator_param;
try {
	$simulator = SimulateRead->new(%simulator_param);
} catch {
	error "$_";
};

#-------------------------------------------------------------------------------
#  Let's simulate it!
#-------------------------------------------------------------------------------
log_msg ":: Running simulation ...";
try {
	$simulator->run_simulation;
} catch {
	error "$_";
};

log_msg ":: End simulation. So Long, and Thanks for All the Fish!";

__END__

=head1 NAME

simulate_reads - Creates single-end and paired-end fastq reads for transcriptome and genome simulation 

=head1 SYNOPSIS

 simulate_reads [options] <fasta-file>

 Options:
  --help               brief help message
  --man                full documentation
  --verbose            print log
  --prefix             prefix output	
  --jobs               number of jobs
  --output-gzip        compress output file
  --coverage           fasta-file coverage
  --number-of-reads    directly set the number of reads
  --sequencing-type    single-end or paired-end reads
  --sequencing-system  illumina sequencing systems
  --sequencing-error   sequencing error rate
  --read-size          the read size
  --fragment-mean      the mean size fragments for paired-end reads
  --fragment-stdd      the standard deviation for fragment sizes
  --strand-bias        which strand to be used: plus, minus and random
  --seqid-weight       seqid raffle type: length, same, file
  --weight-file        weight file when seqid-weight=file

=head1 OPTIONS

B<simulate_reads> has a serie of default options, so that if the user wants, she could
just set a mandatory fasta file and it is enough. These default options are:

 --------------------------------
  Option              Value
 --------------------------------
  verbose             none 
  prefix              out
  jobs                1 
  output_gzip         none  
  coverage            1 
  strand-bias         random 
  seqid-weight        length
  sequencing_type     paired-end 
  fragment_mean       300 
  fragment_stdd       50 
  sequencing_error    0.005
  read-size           101 
  sequencing_system   hiseq 
 --------------------------------

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=item B<--verbose>

Prints log information to standard error

=item B<--prefix>

Concatenates the prefix to the output-file name.
Useful for passing custom directory for output-file

=item B<--jobs>

Sets the number of child jobs to be created

=item B<--output-gzip>

Compress the output-file with gzip algorithm. It is
possible to pass --no-output-gzip if one wants
uncompressed output-file

=item B<--read-size>

Sets the read size. For now the unique valid value is 101

=item B<--coverage>

Calculates the number of reads based on the sequence
coverage: number_of_reads = (sequence_size * coverage) / read_size

=item B<--number-of-reads>

Sets directly the number of reads desired. It overrides coverage,
in case the two options are given

=item B<--sequencing-type>

Sets the sequencing type to single-end or paired-end

=item B<--fragment-mean>

If the sequencing-type is set to paired-end, it sets the
fragment mean

=item B<--fragment-stdd>

If the sequencing-type is set to paired-end, it sets the
fragment standard deviation

=item B<--sequencing-error>

Sets the sequencing error rate. Valid values are between zero and one

=item B<--sequencing-system>

Sets the illumina sequencing system. For now, the unique valid value is hiseq

=item B<--strand-bias>

Sets which strand to use to make a read. Valid options are plus, minus and
random - if you want to randomly calculte the strand for each read

=item B<--seqid-weight>

Sets the seqid (e.g. chromossome, ensembl id) raffle behavior. Valid options are
length, same and file. If it is set to 'same', all seqid receives the same weight
when raffling. If it is set to 'length', the seqid weight is calculated based on
the seqid sequence length. And finally, if it is set to 'file', the user must set
the option --weight-file. For details, see B<--weight-file>

=item B<--weight-file>

If --seqid-weight is set to file, then this option becomes mandatory. A valid
weight file is a tab-separated values file with 2 columns. The first column is
for the seqid and the second column for the desired weight. Valid weights are integers

=back

=head1 DESCRIPTION

B<simulate_reads> will read the given input file and do something
useful with the contents thereof.

=head1 AUTHOR

Thiago Miller - L<tmiller@mochsl.org.br>

=cut
