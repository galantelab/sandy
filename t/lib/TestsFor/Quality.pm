#
#===============================================================================
#
#         FILE: Quality.pm
#
#  DESCRIPTION: Tests for 'Quality' class
#
#        FILES: ---
#         BUGS: ---
#        NOTES: ---
#       AUTHOR: Thiago Miller (tmiller), tmiller@mochsl.org.br
# ORGANIZATION: Group of Bioinformatics
#      VERSION: 1.0
#      CREATED: 12-05-2017 23:13:23
#     REVISION: ---
#===============================================================================
 
package TestsFor::Quality;

use Test::Most;
use autodie;
use base 'TestsFor';

use constant {
	QUALITY       => '.data.txt',
	QUALITY_SIZE  => 10,
	QUALITY_LINES => 25
};

sub startup : Tests(startup) {
	my $test = shift;
	$test->SUPER::startup;
	my $class = ref $test;
	$class->mk_classdata('default_quality');
	$class->mk_classdata('default_attr');

	my $quality = q{*++++,,--.
,)+-0,*,/~
,)+-0,*,/~
,)+-0,*,/~
,)+-0,*,/~
,)+-0,*,/~
,)+*0,*,/~
,)+*0,*,/~
,)+*0,*,/~
*(+*0,*11~
*(+*),+11~
*(+*),+11~
*(+*),+11~
*(+*),+11~
*(+*)/011~
*(-*)/011~
*(-*)/011~
*(-.)/011~
*(-.)/011~
*(-.)/011~
*(-.)/011/
*(-.)-011/
*(-.)-011/
*+-.)-011/
*+-.)-011/};

	open my $fh, ">" => QUALITY;
	print $fh "$quality\n";
	close $fh;
}

sub setup : Tests(setup) {
	my $test = shift;
	my %child_arg = @_;
	$test->SUPER::setup;

	my %default_attr = (
		quality_matrix => QUALITY,
		quality_size   => QUALITY_SIZE,
		%child_arg
	);

	$test->default_attr(\%default_attr);
	$test->default_quality($test->class_to_test->new(%default_attr));
}

sub cleanup : Tests(shutdown) {
	my $test = shift;
	unlink QUALITY;
	$test->SUPER::shutdown;
}

sub constructor : Tests(7) {
	my $test = shift;

	my $class = $test->class_to_test;
	my $quality = $test->default_quality;
	my %default_attr = %{ $test->default_attr };

	while (my ($attr, $value) = each %default_attr) {
		can_ok $quality, $attr;
		is $quality->$attr, $value, "The value for $attr shold be correct";
	}

	my %attrs = %default_attr;
	$attrs{quality_size} = 0;
	throws_ok { $class->new(%attrs) }
	qr/must be greater than zero/,
		"Setting quality_size to less than zero should fail";

	$attrs{quality_size} = 11;
	$attrs{quality_matrix} = "ponga";
	throws_ok { $class->new(%attrs) }
	qr/must be a file/,
		"Setting quality_matrix to a non existing file should fail";

	$attrs{quality_matrix} = QUALITY;
	my $quality2 = $class->new(%attrs);
	throws_ok { $quality2->gen_quality }
	qr/quality_size required is greater than the length at/,
		"Setting quality_size to a value greater than __LINE__ length should fail";
}

sub gen_quality : Test(20) {
	my $test = shift;

	my $class = $test->class_to_test;
	my $quality = $test->default_quality;
	
	for my $i (1..10) {
		my $q = $quality->gen_quality;
		is length $q, $quality->quality_size,
			"quality length should be equal quality_size. Try $i";
	}

	my @qlines;
	push @qlines => $quality->gen_quality for 1..1000;
	
	my $qfreq = $test->_freq_pos(\@qlines);

	open my $fh, "<" => QUALITY;	
	my @lines = <$fh>;
	close $fh;
	my $lfreq = $test->_freq_pos(\@lines);
	
	for (my $i = 0; $i < QUALITY_SIZE; $i++) {
		my $qpos = $qfreq->[$i];
		my $qstr = join "" => sort {$qpos->{$a} <=> $qpos->{$b}} keys %$qpos;
		my $lpos = $lfreq->[$i];
		my $lstr = join "" => sort {$lpos->{$a} <=> $lpos->{$b}} keys %$lpos;

		ok $qstr eq $lstr,
			"The frequence at quality_matrix and the strings generated by gen_quality should be equal at position $i";
	}
}

sub _freq_pos {
	my ($test, $lines) = @_;
	my @pos;
	for (@{ $lines }) {
		chomp;
		my @sym = split //;
		for (my $i = 0; $i <= $#sym; $i++ ) {
			$pos[$i]{$sym[$i]} ++;
		}
	}
	
	return \@pos;
}

1;
